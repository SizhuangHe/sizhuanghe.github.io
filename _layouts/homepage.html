<!DOCTYPE html>
<html lang="{{ site.lang | default: "en-US" }}">
  <head>
    <title>{{ site.title }} | {{site.affiliation}}</title>

    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="{{ site.description }}">
    {% if site.keywords %}
    <meta name="keywords" content="{{ site.keywords }}">
    {% endif %}
    {% if site.canonical %}
    <link rel="canonical" href="{{ site.canonical }}"/>
    {% endif %}

    <link rel="icon" media="(prefers-color-scheme:dark)" href="{{ site.favicon_dark }}" type="image/png" />
    <link rel="icon" media="(prefers-color-scheme:light)" href="{{ site.favicon }}" type="image/png" />
    <script src="./assets/js/favicon-switcher.js" type="application/javascript"></script>

    <link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/academicons/1.8.6/css/academicons.min.css integrity="sha256-uFVgMKfistnJAfoCUQigIl+JfUaP47GrRKjf6CTPVmw=" crossorigin=anonymous>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css" integrity="sha512-z3gLpd7yknf1YoNbCzqRKc4qyor8gaKU1qmn+CShxbuBusANI9QpRohGBreCFkKxLhei6S9CQXFEbbKuqLg0DA==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    
    {% if site.font == "Sans Serif" %}
    <link rel="stylesheet" href="./assets/css/font_sans_serif.css">
    {% else %}
    <link rel="stylesheet" href="./assets/css/font.css">
    {% endif %}
    {% if site.auto_dark_mode %}
    <link rel="stylesheet" href="./assets/css/style.css">
    <link rel="stylesheet" href="./assets/css/publications.css">
    {% else %}
    <link rel="stylesheet" href="./assets/css/style-no-dark-mode.css">
    <link rel="stylesheet" href="./assets/css/publications-no-dark-mode.css">
    {% endif %}

  </head>
  <body>

    <div class="wrapper">
      <header>
        
        {% if site.avatar %}
        <a class="image avatar"><img id="random-avatar" src="{{ site.avatar }}" alt="avatar" /></a>
        {% endif %}

        <h1>{{ site.title }}</h1>

        {% if site.position %}
        <position style="font-size:1.10rem;">{{ site.position }}</position>
        <br>
        {% endif %}
        {% if site.affiliation %}
        <a href="{{ site.affiliation_link }}" rel="noopener"><autocolor>{{ site.affiliation }}</autocolor></a>
        <br>
        {% endif %}
        {% if site.email %}
        <email>{{ site.email }}</email>
        {% endif %}


        <br>
        <br>
        <div class="social-icons">

        {% if site.cv_link %}
        <a style="margin: 0 5px 0 0" href="{{ site.cv_link }}">
          <i class="ai ai-cv" style="font-size:1.3rem;"></i>
        </a>
        {% endif %}

        {% if site.github_link %}
        <a style="margin: 0 5px 0 0" href="{{ site.github_link }}">
          <i class="fab fa-github"></i>
        </a>
        {% endif %}

        {% if site.linkedin %}
        <a style="margin: 0 5px 0 0" href="{{ site.linkedin }}">
          <i class="fab fa-linkedin"></i>
        </a>
        {% endif %}

        {% if site.twitter %}
        <a style="margin: 0 0 0 0" href="{{ site.twitter }}">
          <i class="fab fa-x-twitter"></i>
        </a>
        {% endif %}
        </div>

        <!-- Google Scholar Statistics -->
        <div class="scholar-stats">
          <div class="stats-container" id="scholar-stats">
            {% if site.google_scholar %}
            <div class="scholar-icon">
              <a href="{{ site.google_scholar }}" target="_blank" rel="noopener">
                <i class="ai ai-google-scholar" style="font-size:1.5rem"></i>
              </a>
            </div>
            {% endif %}
            <div class="stat-item">
              <div class="stat-number" id="citations">Loading...</div>
              <div class="stat-label">Citations</div>
            </div>
            <div class="stat-item">
              <div class="stat-number" id="h-index">Loading...</div>
              <div class="stat-label">H-Index</div>
            </div>
          </div>
          <div class="last-updated" id="last-updated" style="font-size: 0.6rem; color: #666; margin-top: 0.3rem; text-align: center;">
            Last updated: <span id="update-time">Loading...</span>
          </div>
        </div>

      </header>
      <section>

      {{ content }}

      <br>

      {% if site.enable_footnote %}
      <p><small>Powered by Jekyll and <a href="https://github.com/yaoyao-liu/minimal-light" target="_blank" rel="noopener">Minimal Light</a> theme.</small></p>
      {% endif %}

      </section>
      <footer>
        
      </footer>
    </div>
    <script src="{{ "/assets/js/scale.fix.js" | relative_url }}"></script>
    <script>
      // Google Scholar Stats Loading
      async function loadScholarStats() {
        // Check if we're on localhost (development)
        if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
          // Show mock data for local development
          document.getElementById('citations').textContent = '1,234';
          document.getElementById('h-index').textContent = '12';
          return;
        }
        
        try {
          const response = await fetch('https://raw.githubusercontent.com/SizhuangHe/sizhuanghe.github.io/google-scholar-stats/gs_data.json');
          if (!response.ok) {
            throw new Error('Failed to fetch stats');
          }
          
          const data = await response.json();
          
          // Update the display
          document.getElementById('citations').textContent = data.citedby?.toLocaleString() || '0';
          document.getElementById('h-index').textContent = data.hindex || '0';
          
          // Update last updated time
          if (data.updated) {
            const updateDate = new Date(data.updated);
            const formattedDate = updateDate.toLocaleDateString('en-US', {
              year: 'numeric',
              month: 'short',
              day: 'numeric',
              hour: '2-digit',
              minute: '2-digit'
            });
            document.getElementById('update-time').textContent = formattedDate;
          }
          
        } catch (error) {
          console.log('Could not load Google Scholar stats:', error);
          // Show fallback values
          document.getElementById('citations').textContent = '0';
          document.getElementById('h-index').textContent = '0';
          document.getElementById('update-time').textContent = 'Unable to load';
        }
      }

      // Load stats when the page loads
      document.addEventListener('DOMContentLoaded', loadScholarStats);

      function toggleAuthors(element) {
        const truncated = element.previousElementSibling;
        const full = element.nextElementSibling;
        
        // Store original texts and HTML if not already stored
        if (!full.dataset.originalText) {
          full.dataset.originalText = full.textContent;
          full.dataset.originalHtml = full.innerHTML;
          full.dataset.truncatedText = truncated.textContent;
          full.dataset.truncatedHtml = truncated.innerHTML;
        }
        
        // Hide truncated version and toggle button
        truncated.style.display = 'none';
        element.style.display = 'none';
        
        // Get the stored original texts
        const fullText = full.dataset.originalText;
        const truncatedText = full.dataset.truncatedText;
        
        // Find the additional text (what's hidden)
        const additionalText = fullText.replace(truncatedText, '');
        
        // Show the full span with only the truncated HTML initially
        full.innerHTML = full.dataset.truncatedHtml;
        full.style.display = 'inline';
        full.classList.add('expanded');
        
        // Create a span for the additional text that will be animated
        const animatedSpan = document.createElement('span');
        full.appendChild(animatedSpan);
        
        // Animate character by character for only the additional text
        let charIndex = 0;
        const animateChar = () => {
          if (charIndex < additionalText.length) {
            animatedSpan.textContent += additionalText[charIndex];
            charIndex++;
            setTimeout(animateChar, 5); // 5ms between characters
          } else {
            // Add collapse button after animation is complete
            const collapseButton = document.createElement('span');
            collapseButton.className = 'author-collapse';
            collapseButton.style.color = '#888888';
            collapseButton.style.cursor = 'pointer';
            collapseButton.style.textDecoration = 'underline dashed';
            collapseButton.style.marginLeft = '5px';
            collapseButton.innerHTML = 'show less';
            collapseButton.onclick = function() { collapseAuthors(this); };
            
            full.appendChild(document.createTextNode(' '));
            full.appendChild(collapseButton);
          }
        };
        
        // Start the animation
        setTimeout(animateChar, 100);
      }
      
      function collapseAuthors(element) {
        const fullSpan = element.parentElement;
        const authorDiv = fullSpan.parentElement;
        const truncated = authorDiv.querySelector('.author-truncated');
        const toggle = authorDiv.querySelector('.author-toggle');
        
        // Remove the collapse button and space
        element.previousSibling.remove(); // Remove space
        element.remove(); // Remove button
        
        // Get the stored texts
        const truncatedText = fullSpan.dataset.truncatedText;
        const fullText = fullSpan.dataset.originalText;
        
        // Find the additional text that needs to be removed
        const additionalText = fullText.replace(truncatedText, '');
        
        // Find the animated span (last child before the button was removed)
        const animatedSpan = fullSpan.lastElementChild || fullSpan.lastChild;
        
        // Reverse animation - remove characters one by one from the animated span
        let charIndex = additionalText.length;
        const removeChar = () => {
          if (charIndex > 0) {
            charIndex--;
            if (animatedSpan && animatedSpan.nodeType === Node.TEXT_NODE) {
              animatedSpan.textContent = additionalText.substring(0, charIndex);
            } else if (animatedSpan) {
              animatedSpan.textContent = additionalText.substring(0, charIndex);
            }
            setTimeout(removeChar, 5); // 5ms between character removal
          } else {
            // After reverse animation, hide full and show truncated
            fullSpan.style.display = 'none';
            fullSpan.classList.remove('expanded');
            truncated.style.display = 'inline';
            toggle.style.display = 'inline';
          }
        };
        
        // Start the reverse animation
        removeChar();
      }

      // Tag filtering functionality
      let activeFilters = new Set();

      function toggleTagFilter(tag, element) {
        if (activeFilters.has(tag)) {
          activeFilters.delete(tag);
          element.classList.remove('active');
        } else {
          activeFilters.add(tag);
          element.classList.add('active');
        }
        
        filterPublications();
      }

      function clearAllFilters() {
        activeFilters.clear();
        document.querySelectorAll('.tag-filter').forEach(el => el.classList.remove('active'));
        filterPublications();
      }

      function filterPublications() {
        const publications = document.querySelectorAll('.publication-item');
        
        publications.forEach(pub => {
          if (activeFilters.size === 0) {
            pub.style.display = '';
          } else {
            const pubTags = JSON.parse(pub.getAttribute('data-tags') || '[]');
            const hasMatchingTag = pubTags.some(tag => activeFilters.has(tag));
            pub.style.display = hasMatchingTag ? '' : 'none';
          }
          
          // Highlight matching tags on individual publications
          const pubTagElements = pub.querySelectorAll('.pub-tag');
          pubTagElements.forEach(tagElement => {
            const tagText = tagElement.textContent.replace('# ', ''); // Remove "# " for comparison
            if (activeFilters.has(tagText)) {
              tagElement.classList.add('highlighted');
            } else {
              tagElement.classList.remove('highlighted');
            }
          });
        });

        // Hide year sections with no visible publications
        const yearSections = document.querySelectorAll('.year-section');
        yearSections.forEach(yearSection => {
          const visiblePubsInYear = yearSection.querySelectorAll('.publication-item').length;
          const hiddenPubsInYear = yearSection.querySelectorAll('.publication-item[style*="display: none"]').length;
          
          if (visiblePubsInYear === hiddenPubsInYear) {
            yearSection.style.display = 'none';
          } else {
            yearSection.style.display = '';
          }
        });

        // Update filter count
        const visibleCount = Array.from(publications).filter(pub => pub.style.display !== 'none').length;
        const countElement = document.getElementById('filter-count');
        if (countElement) {
          if (activeFilters.size === 0) {
            countElement.textContent = '';
          } else {
            countElement.textContent = `Showing ${visibleCount} of ${publications.length} publications`;
          }
        }
      }

      // Publication tag click functionality
      function toggleTagFromPublication(tag, element) {
        // Find the corresponding filter tag and activate it
        const filterTags = document.querySelectorAll('.tag-filter');
        let filterTag = null;
        
        filterTags.forEach(ft => {
          if (ft.textContent === '# ' + tag) {
            filterTag = ft;
          }
        });
        
        if (filterTag) {
          // Toggle the filter tag
          toggleTagFilter(tag, filterTag);
          
          // Expand the filter box if it's collapsed and update text
          const filterContent = document.getElementById('filter-content');
          const toggleText = document.getElementById('filter-toggle-text');
          if (filterContent && !filterContent.classList.contains('expanded')) {
            filterContent.classList.add('expanded');
            if (toggleText) {
              toggleText.textContent = 'Collapse Research Area';
            }
          }
        }
      }

      // Collapsible filter box functionality
      function toggleFilterBox() {
        const content = document.getElementById('filter-content');
        const toggleText = document.getElementById('filter-toggle-text');
        
        if (content.classList.contains('expanded')) {
          content.classList.remove('expanded');
          toggleText.textContent = 'Filter by Research Area';
        } else {
          content.classList.add('expanded');
          toggleText.textContent = 'Collapse Research Area';
        }
      }

    </script>
    {% if site.google_analytics %}
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
      ga('create', '{{ site.google_analytics }}', 'auto');
      ga('send', 'pageview');
    </script>
    {% endif %}
    
    <style>
      /* Google Scholar Stats Sidebar Styles */
      .scholar-stats {
        margin: 0.2rem 0 0.5rem 0;
        padding: 0.5rem;
        background: #f8f9fa;
        border-radius: 4px;
        text-align: center;
      }

      .stats-container {
        display: flex;
        justify-content: space-between;
        gap: 0.4rem;
        align-items: center;
      }

      .stat-item {
        text-align: center;
        flex: 1;
      }

      .stat-number {
        font-size: 1.2rem;
        font-weight: bold;
        color: var(--global-theme-color);
        margin-bottom: 0.1rem;
        line-height: 1;
      }

      .stat-label {
        font-size: 0.65rem;
        color: #666;
        text-transform: uppercase;
        letter-spacing: 0.2px;
        line-height: 1;
      }

      .scholar-icon {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        text-align: center;
        flex: 1;
        min-height: 2.5rem;
      }

      .scholar-icon a {
        color: var(--global-theme-color);
        text-decoration: none;
        transition: opacity 0.2s ease;
      }

      .scholar-icon a:hover {
        opacity: 0.7;
      }

      .scholar-label {
        font-size: 0.65rem;
        color: #666;
        text-transform: uppercase;
        letter-spacing: 0.2px;
        line-height: 1;
        margin-top: 0.1rem;
      }

      @media (max-width: 768px) {
        .stats-container {
          gap: 0.3rem;
        }
        
        .stat-number {
          font-size: 1.1rem;
        }
        
        .stat-label {
          font-size: 0.7rem;
        }
      }

      @media (prefers-color-scheme: dark) {
        .scholar-stats {
          background: #2d3748 !important;
        }
        
        .stat-label {
          color: #a0aec0 !important;
        }
        
        .scholar-label {
          color: #a0aec0 !important;
        }
      }

      /* BibTeX inline container styles */
      .bibtex-container {
        box-shadow: 0 1px 3px rgba(0,0,0,0.1);
      }
      
      .bibtex-code {
        font-feature-settings: "liga" 0;
        tab-size: 2;
      }
      
      /* Tag system styles */
      .tag-filters {
        margin: 8px 0;
        padding: 0;
      }
      
      .filter-header {
        user-select: none;
        transition: color 0.2s ease;
        text-decoration: underline;
        text-decoration-style: dashed;
      }
      
      .filter-header:hover {
        color: #007bff !important;
      }
      
      
      .filter-content {
        transition: all 0.3s ease;
        overflow: hidden;
        margin-top: 10px;
        max-height: 0;
        opacity: 0;
      }
      
      .filter-content.expanded {
        max-height: 200px;
        opacity: 1;
      }
      
      /* Author expansion animation */
      .author-full {
        max-height: 0;
        opacity: 0;
        overflow: hidden;
        transition: all 0.3s ease;
      }
      
      .author-full.expanded {
        max-height: 100px;
        opacity: 1;
      }
      
      .tag-filter {
        display: inline-block;
        margin: 3px;
        padding: 2px 8px;
        background-color: #e9ecef;
        border: 1px solid #ced4da;
        border-radius: 12px;
        font-size: 0.75em;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s ease;
        color: #495057;
      }
      
      .tag-filter:hover {
        background-color: #e8f0fe;
        border-color: #4285f4;
        color: #1a73e8;
      }
      
      .tag-filter.active {
        background-color: #007bff;
        color: white;
        border-color: #0056b3;
      }
      
      .clear-filters {
        display: inline-block;
        margin: 3px;
        margin-left: 10px;
        padding: 4px 10px;
        background-color: #ffeaea;
        border: 1px solid #ffcdd2;
        border-radius: 12px;
        font-size: 0.75em;
        font-weight: 500;
        font-family: inherit;
        line-height: normal;
        box-sizing: border-box;
        vertical-align: baseline;
        cursor: pointer;
        transition: all 0.2s ease;
        color: #c62828;
      }
      
      .clear-filters:hover {
        background-color: #d32f2f;
        color: white;
        border-color: #d32f2f;
        transform: translateY(-1px);
        box-shadow: 0 2px 8px rgba(211, 47, 47, 0.25);
      }

      .filter-count {
        margin-top: 8px;
        font-size: 0.9em;
        color: #6c757d;
        font-style: italic;
      }
      
      /* Action buttons hover effects */
      .btn.btn-sm.z-depth-0:hover {
        background-color: #e8f0fe !important;
        border-color: #4285f4 !important;
        color: #1a73e8 !important;
        transform: translateY(-1px);
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      }
      
      /* Individual publication tags */
      .publication-tags {
        margin-bottom: 3px;
      }
      
      .pub-tag {
        display: inline-block;
        margin: 2px 4px 2px 0;
        padding: 2px 8px;
        background-color: #f1f3f4;
        border: 1px solid #dadce0;
        border-radius: 12px;
        font-size: 0.75em;
        color: #5f6368;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s ease;
      }
      
      .pub-tag:hover {
        background-color: #e8f0fe;
        border-color: #4285f4;
        color: #1a73e8;
      }
      
      .pub-tag.highlighted {
        background-color: #007bff;
        border-color: #0056b3;
        color: white;
        font-weight: 600;
      }
      
      @media (prefers-color-scheme: dark) {
         .bibtex-container {
           background-color: #2d3748 !important;
           border-left-color: #c2cedc !important;
         }
        
        .bibtex-container strong {
          color: #e2e8f0 !important;
        }
        
        .bibtex-container pre {
          color: #e2e8f0 !important;
        }
        
        .bibtex-container button {
          background-color: #4a5568 !important;
          color: #e2e8f0 !important;
          border-color: #718096 !important;
        }
        
        .bibtex-container button:hover {
          background-color: #718096 !important;
        }
        
           /* Abstract container dark mode */
           .abstract-container {
             background-color: #2d3748 !important;
             border-left-color: #e6d6d9 !important;
           }
        
        .abstract-container div {
          color: #e2e8f0 !important;
        }
        
        .abstract-container button {
          background-color: #4a5568 !important;
          color: #e2e8f0 !important;
          border-color: #718096 !important;
        }
        
        .abstract-container button:hover {
          background-color: #718096 !important;
        }
        
        /* Selected publications dark mode */
        .abstract[style*="color: #666"] {
          color: #ffffff !important;
        }
        
        /* Author toggle links in dark mode - lighter gray */
        .author-toggle {
          color: #bbbbbb !important;
        }
        
        /* Action buttons dark mode hover effects */
        .btn.btn-sm.z-depth-0:hover {
          background-color: #2d3748 !important;
          border-color: #4299e1 !important;
          color: #63b3ed !important;
          transform: translateY(-1px);
          box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        
        /* Tag system dark mode styles */
        
        .tag-filter {
          background-color: #4a5568 !important;
          color: #e2e8f0 !important;
          border-color: #718096 !important;
        }
        
        .tag-filter:hover {
          background-color: #2d3748 !important;
          border-color: #4299e1 !important;
          color: #63b3ed !important;
        }
        
        .tag-filter.active {
          background-color: #3182ce !important;
          color: #ffffff !important;
          border-color: #2c5aa0 !important;
        }
        
        .clear-filters {
          background-color: #4a2c2a !important;
          border-color: #5d4037 !important;
          color: #ffcdd2 !important;
        }
        
        .clear-filters:hover {
          background-color: #ffcdd2 !important;
          color: #2d1b1e !important;
          border-color: #ffcdd2 !important;
          transform: translateY(-1px);
          box-shadow: 0 2px 8px rgba(255, 205, 210, 0.3);
        }

        .filter-count {
          color: #a0aec0 !important;
        }
        
        .filter-header {
          color: #e2e8f0 !important;
        }
        
        .filter-header:hover {
          color: #63b3ed !important;
        }
        
        /* Individual publication tags dark mode */
        .pub-tag {
          background-color: #4a5568 !important;
          border-color: #718096 !important;
          color: #cbd5e0 !important;
        }
        
        .pub-tag:hover {
          background-color: #2d3748 !important;
          border-color: #4299e1 !important;
          color: #63b3ed !important;
        }
        
        .pub-tag.highlighted {
          background-color: #3182ce !important;
          border-color: #2c5aa0 !important;
          color: #ffffff !important;
        }
        
        /* Selected publications titles - match section headers in dark mode */
        .title[style*="color: #043361"] {
          color: rgb(62, 183, 240) !important;
        }
        
        /* Selected publications links - match About Me link colors */
        .abstract a:hover {
          color: #069 !important;
        }
        
           
           
           /* Dark mode syntax highlighting */
           .bibtex-container .bibtex-code span[style*="color: #6f42c1"] {
             color: #ff79c6 !important; /* Purple for @article */
           }
        
        .bibtex-container .bibtex-code span[style*="color: #e36209"] {
          color: #50fa7b !important; /* Green for field names */
        }
        
        .bibtex-container .bibtex-code span[style*="color: #032f62"] {
          color: #f1fa8c !important; /* Yellow for values */
        }
        
        .bibtex-container .bibtex-code span[style*="color: #24292e"] {
          color: #e2e8f0 !important; /* Light gray for punctuation */
        }
      }
    </style>
    
    <!-- Random Avatar Script -->
    <script>
      document.addEventListener('DOMContentLoaded', function() {
        const avatarImages = [
          './assets/img/avatars/brooklyn_bridge.png',
          './assets/img/avatars/kitty.png'
        ];
        
        const randomIndex = Math.floor(Math.random() * avatarImages.length);
        const randomAvatar = avatarImages[randomIndex];
        
        const avatarElement = document.getElementById('random-avatar');
        if (avatarElement) {
          avatarElement.src = randomAvatar;
        }
      });
      
      // BibTeX Inline Functions
      window.toggleBibtex = function(containerId, bibtexUrl) {
        const container = document.getElementById(containerId);
        const preElement = document.getElementById('bibtex-content-' + containerId.split('-')[1]);
        
        if (container.style.display === 'none' || container.style.display === '') {
          // Show the text box and load content if not already loaded
          if (preElement.textContent === '') {
            fetch(bibtexUrl)
              .then(response => response.text())
              .then(bibtexContent => {
                // Clean the BibTeX content (remove abstract)
                const cleanedBibtex = cleanBibtexContent(bibtexContent);
                // Apply syntax highlighting
                preElement.innerHTML = highlightBibtex(cleanedBibtex);
              })
              .catch(error => {
                console.error('Error loading BibTeX:', error);
                preElement.textContent = 'Error loading BibTeX content.';
              });
          }
          container.style.display = 'block';
        } else {
          // Hide the display
          container.style.display = 'none';
        }
      };
      
      window.copyBibtexContent = function(preElementId) {
        const preElement = document.getElementById(preElementId);
        const textContent = preElement.textContent || preElement.innerText;
        
        // Create a temporary textarea to copy the plain text
        const tempTextArea = document.createElement('textarea');
        tempTextArea.value = textContent;
        document.body.appendChild(tempTextArea);
        tempTextArea.select();
        tempTextArea.setSelectionRange(0, 99999);
        
        try {
          document.execCommand('copy');
          document.body.removeChild(tempTextArea);
          
          // Provide visual feedback by changing the icon temporarily
          const copyButton = event.target.closest('button');
          const svg = copyButton.querySelector('svg');
          const originalHTML = svg.innerHTML;
          
          // Change to checkmark icon
          svg.innerHTML = '<path d="M20 6L9 17l-5-5"></path>';
          copyButton.style.color = '#28a745';
          
          setTimeout(() => {
            svg.innerHTML = originalHTML;
            copyButton.style.color = '#495057';
          }, 2000);
        } catch (err) {
          console.error('Failed to copy: ', err);
          if (document.body.contains(tempTextArea)) {
            document.body.removeChild(tempTextArea);
          }
        }
      };
      
      // Abstract Toggle Functions
      window.toggleAbstract = function(containerId) {
        const container = document.getElementById(containerId);
        
        if (container.style.display === 'none' || container.style.display === '') {
          container.style.display = 'block';
        } else {
          container.style.display = 'none';
        }
      };
      
      // Function to apply syntax highlighting to BibTeX
      function highlightBibtex(bibtexContent) {
        // Escape HTML first to prevent conflicts
        let highlighted = bibtexContent
          .replace(/&/g, '&amp;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;');
        
        // Apply syntax highlighting
        highlighted = highlighted
          // Highlight entry type and key (e.g., @article{key,)
          .replace(/(@\w+)(\{)([^,\s\}]+)(,?)/g, '<span style="color: #6f42c1;">$1</span><span style="color: #24292e;">$2</span><span style="color: #032f62;">$3</span><span style="color: #24292e;">$4</span>')
          // Highlight field names (e.g., title =, author =)
          .replace(/^(\s+)(\w+)(\s*=\s*)/gm, '$1<span style="color: #e36209;">$2</span><span style="color: #24292e;">$3</span>')
          // Highlight field values in braces - handle nested braces properly
          .replace(/(\{)([^{}]*(?:\{[^{}]*\}[^{}]*)*)(\})/g, function(match, openBrace, content, closeBrace) {
            return '<span style="color: #24292e;">' + openBrace + '</span><span style="color: #032f62;">' + content + '</span><span style="color: #24292e;">' + closeBrace + '</span>';
          })
          // Highlight closing brace of entry
          .replace(/^(\s*)(\})(\s*)$/gm, '$1<span style="color: #24292e;">$2</span>$3');
          
        return highlighted;
      }
      
      // Function to clean BibTeX content by removing abstract field
      function cleanBibtexContent(bibtexContent) {
        // Remove abstract field and its content
        // This regex matches the abstract field including multi-line content
        const abstractRegex = /,?\s*abstract\s*=\s*\{[^{}]*(?:\{[^{}]*\}[^{}]*)*\}/gi;
        let cleaned = bibtexContent.replace(abstractRegex, '');
        
        // Clean up any double commas that might result from removing abstract
        cleaned = cleaned.replace(/,\s*,/g, ',');
        
        // Clean up comma before closing brace
        cleaned = cleaned.replace(/,(\s*\})/g, '$1');
        
        return cleaned.trim();
      }
    </script>
  </body>
</html>


